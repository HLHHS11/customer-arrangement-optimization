プログラムに必要な機能を検討する

/** 
絶対役立つと思うリンク：https://note.nkmk.me/python-numpy-count/
*/

必要な機能
①全通りの配置図を作成する機能 {
    余力があれば、対称性を考慮して削れるところは削っていく
    
    そもそも、もとの二次元配列chairの完成品をもとにして座席の場所を取得するのか、
    chairの生成ルールをもとに、forを用いて計算によって座席の場所一覧を作成するのか、
    というところも考えてみたい。
    ただし、この処理はどちみち一回のプログラム実行で一回しか呼び出されない。
    ボトルネックとなりうるのは、全通りの配置図を作成する部分や、その後の１の数を数える部分である

    後者の方法で0の位置一覧を作るためのメモ {
        ０（座席）が存在しうる位置↓
            row mod 3 = 0,2 && column mod 3 = 1
            row mod 3 = 1   && column mod 3 = 0,2
        これを満たす数字の組の配列をfor等を用いて作成する
        でも、これを唯一の配列に格納するのではなく、
        各合同式の組によって異なる配列に格納する（このとき配列は４つ用意することになる）
        ようにすれば、「配列の組の値をもとにして、客の向いている向きを判断する」必要がなくなる
        一方で、この方式にすると1をどう分配するかがちょっと難しくなるかも。
        あと、各行・各列の1の数のリストを作るときに、いちいち４つの配列にアクセスする必要性がでてくる
        {
            ↑とみせかけて1配置あたり、２倍に増えるだけで大丈夫。合同式をよく見ればわかる
            一方で０が存在しうる位置の配列を１つにまとめたとしたら？
        }        
    }
}
②各配置図の各１(客を表す)の視界に入る１の数を数える機能 {
    ちゃんと客の向いている向きも考慮することを忘れないこと {
        向きの判定は、おそらく剰余類を用いるのが一番カンタンであろう。
    }

    配置図の骨格について {
        プログラムの考案は少し難しくなるかもしれないが、
        そもそも全配置図をchairのように二次元配列で作る必要性は必ずしもないかもしれない
        「要素１がある座標をインプットすれば、そこの客の向きを判定する」関数さえあれば、
        以下に書いたような「各行・各列の１の数のリスト」とあわせて、
    }
    
    たとえば同じ列に1が複数あったとすると、
    1番目の1から見える他の１の数と、2番目、3番目の１から見える他の１の数は全く同じだ
    それどころか、各行・各列について1の数を数えてリストを作っておけば、それを合計するだけでよい

    ふと思ったこと。まとまってはいないが {
        先述のように1の配置図は、二次元numpy配列で作る方法と、
        1の座標だけをリストや配列に入れる方法とが考えられるが

        そもそも１の位置を全通り試す（←対称性とか考慮したとしても、その組の数は膨大）方法に意味はあるのか？
        最適解を求めるだけなら、全員が外側を向くような座席配置を作ってしまえばよいということになるのでは？

        ↑これは極論で、ある程度コンピュータの力を借りるにしても
        各配置図を細かく作るのではなく、この列に何個の１があって、この行に何個の１があって、
        というのを分配していって計算してもよいのではないか？
        しかしその方法でちゃんと全通り試せるのか、というと少しむずかしいかもしれない
        結局、コンピュータの力はほとんど関係がない、数学の問題ということになるかもしれない

        まぁ結局、全通りを試すプログラムを作成すれば、「見える客の数の総和」の分布図を作ることもできるようになるから
        明らかに見える客の数が多い配置についても考える意味を見出すことはできる
    }
}


プログラムの仕様についてのメモ {
    本来は来客人数を0~48まで全部試したいところだが、
    それは大変なので一旦昼：２６人、夜：４８人ということにしてコーディング
}




------20230108以前のメモ------

# coding: utf-8
# Your code here!

import numpy as np

chair = np.zeros((12,18))

for j in range(6):
    for i in range(4):
        chair[1+3*i,1+3*j] = 3
        chair[3*i,3*j] = 2
        chair[3*i,2+3*j] = 2
        chair[2+3*i,2+3*j] = 2
        chair[2+3*i,3*j] = 2

tempList = []
for k in range(12):
    tempList.append(list(map(lambda x:1 if x==0 else x, chair[k])))

chair_converted = np.array(tempList)
print(chair_converted)






print(chair)

chair_converted = np.array(np.array((list(map(lambda x:1 if x==0 else x, chair[0])))))
print(chair_converted)
for k in range(1,12):
    #chair_converted.append(np.array(map(lambda x:1 if x==0 else x, chair[k])))
    chair_converted = np.append(chair_converted,list(map(lambda x:1 if x==0 else x, chair[k])), axis=0)
    #chair_converted = np.append(chair_converted, np.array([0,1,0,1]))

print(chair_converted)





一応どういう処理の流れか簡単に説明すると

①２層のforループで、二次元配列chairの要素にアクセス
②１個目のifにより、0をみつけたらそれを1に変える&カウンターを１個ふやす
③２個目のifがちょっと難しくて、
もしカウンターの数がしきい値を超えたら、breakで内側のforを抜ける。すると、外側のforに用意してあるbreakにつながるので、外側のforも抜ける。それにより、これ以上置き換え処理を行わなくなる
もしカウンターの数がしきい値を超えなければ、else: continueというところにつながる。これは外側のループを1個