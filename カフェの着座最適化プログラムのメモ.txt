プログラムに必要な機能を検討する

/** 
絶対役立つと思うリンク：https://note.nkmk.me/python-numpy-count/
*/

必要な機能
①全通りの配置図を作成する機能 {
    余力があれば、対称性を考慮して削れるところは削っていく
    
    そもそも、もとの二次元配列chairの完成品をもとにして座席の場所を取得するのか、
    chairの生成ルールをもとに、forを用いて計算によって座席の場所一覧を作成するのか、
    というところも考えてみたい。
    ただし、この処理はどちみち一回のプログラム実行で一回しか呼び出されない。
    ボトルネックとなりうるのは、全通りの配置図を作成する部分や、その後の１の数を数える部分である

    後者の方法で0の位置一覧を作るためのメモ {
        ０（座席）が存在しうる位置↓
            row mod 3 = 0,2 && column mod 3 = 1
            row mod 3 = 1   && column mod 3 = 0,2
        これを満たす数字の組の配列をfor等を用いて作成する
        でも、これを唯一の配列に格納するのではなく、
        各合同式の組によって異なる配列に格納する（このとき配列は４つ用意することになる）
        ようにすれば、「配列の組の値をもとにして、客の向いている向きを判断する」必要がなくなる
        一方で、この方式にすると1をどう分配するかがちょっと難しくなるかも。
        あと、各行・各列の1の数のリストを作るときに、いちいち４つの配列にアクセスする必要性がでてくる
        {
            ↑とみせかけて1配置あたり、２倍に増えるだけで大丈夫。合同式をよく見ればわかる
            一方で０が存在しうる位置の配列を１つにまとめたとしたら？
        }        
    }
}
②各配置図の各１(客を表す)の視界に入る１の数を数える機能 {
    ちゃんと客の向いている向きも考慮することを忘れないこと {
        向きの判定は、おそらく剰余類を用いるのが一番カンタンであろう。
    }

    配置図の骨格について {
        プログラムの考案は少し難しくなるかもしれないが、
        そもそも全配置図をchairのように二次元配列で作る必要性は必ずしもないかもしれない
        「要素１がある座標をインプットすれば、そこの客の向きを判定する」関数さえあれば、
        以下に書いたような「各行・各列の１の数のリスト」とあわせて、
    }
    
    たとえば同じ列に1が複数あったとすると、
    1番目の1から見える他の１の数と、2番目、3番目の１から見える他の１の数は全く同じだ
    それどころか、各行・各列について1の数を数えてリストを作っておけば、それを合計するだけでよい

    ふと思ったこと。まとまってはいないが {
        先述のように1の配置図は、二次元numpy配列で作る方法と、
        1の座標だけをリストや配列に入れる方法とが考えられるが

        そもそも１の位置を全通り試す（←対称性とか考慮したとしても、その組の数は膨大）方法に意味はあるのか？
        最適解を求めるだけなら、全員が外側を向くような座席配置を作ってしまえばよいということになるのでは？

        ↑これは極論で、ある程度コンピュータの力を借りるにしても
        各配置図を細かく作るのではなく、この列に何個の１があって、この行に何個の１があって、
        というのを分配していって計算してもよいのではないか？
        しかしその方法でちゃんと全通り試せるのか、というと少しむずかしいかもしれない
        結局、コンピュータの力はほとんど関係がない、数学の問題ということになるかもしれない

        まぁ結局、全通りを試すプログラムを作成すれば、「見える客の数の総和」の分布図を作ることもできるようになるから
        明らかに見える客の数が多い配置についても考える意味を見出すことはできる
    }
}


プログラムの仕様についてのメモ {
    本来は来客人数を0~48まで全部試したいところだが、
    それは大変なので一旦昼：２６人、夜：４８人ということにしてコーディング
}


組み合わせの配列を作るためのメモ {
    1からnまでの数字	から	r個選ぶ組み合わせ
    ※ゼロスタートじゃなくて1スタートとする
    function combination (n,r) {

        i = 1を固定 {
            //1から残りの数m=n-iまでからr-1個とる組み合わせを作る。最後に+iで修正すること
            n' = n-1
            r' = r-1
            combination(n'=n-1, r'=r-1) {
                i=1を固定{
                    combination(n'-1=n-2, r'-1=r-2) {
                        
                    }
                }
                i=2に固定{
                    combination(n'-2=n-3, r'-2=r-3) {

                    }
                }
                ………
            }
        }
        i = 2を固定 {
            combination(n-2,r-2) {

            }
        ………
        }
    }
	
    ちょっと大変なので、5C3の場合を考える。n=5,r=3
    function combination (n,r,i) {
        j=1のとき { //コーディング時にはforで実装する予定
            //n-1_C_r-1を求める問題に変わる。（ただし最後jを忘れないように)
            combination(n=5, r'=3-1=2, j'=1) {
                //第一要素はj=1
                j'=j+1=2のとき {
                    combination(n=5, r''=r'-1=1, j''=2) {
                        //第２要素はj'=2
                        for(j''=j'+1;)
                        @for j''=j'+1=3のとき {
                            combination(n=5,r'''=0,j'''=3) {
                                r'''=0であるから、最後の要素にj'''が入る
                                return j''=3
                            }
                            tempArray[0].push(arrElement=3);
                        }
                        @for j''=j'+2=4のとき {
                            combination(n=5、r'''=0,j'''=4) {
                                r'''=0より、最後の要素にj'''が入る
                                return j''=4
                            }
                            tempArray[1].push(arrElement=4);
                        }
                        @for j''=j'+3=5のとき {
                            combination(n=5、r'''=0,j'''=5) {
                                r'''=0より、最後の要素にj'''が入る
                                return j''=5
                            }
                            tempArray[2].push(arrElement=5);
                        }
                        for (j''=j'+1; j''<=5; j''++) {
                            combination(5,0,j'')
                            tempArray
                        }
                        //forが終わってcombinationArrの中身は[ [3],[4],[5] ]になった
                        r''=1であるから、最後から1個前の要素にj''が入る
                        うまくやってtempArrayの中身を
                        [ [2,3],[2,4],[2,5] ]にする
                        return tempArray
                    }

                }
            }
        }
    }


    初回呼び出しと再帰呼び出し合わせて、r回呼び出される
    関数のループは、渡されたiを1個増やしたところからスタート
        rを1個減らし、iをループ内の値にあわせて呼び出し combination(n,r-1,i)
    function combination(n,r,i) {
        for(i+1からnまで) {
            
        }
    }

}



------20230110プログラムから削除したコード------

"""
#配列arrangementをもとにして座席図を作る方法
#次のコミットで消す
seat_position = []
for k in range(12):
    for l in range(18):
        if arrangement[k,l] == 0:
            seat_position.append([k,l])

#ランダムに0→1置換処理
MAX_NUMBER_OF_1 = 30    #
random.shuffle(seat_position)
for m in range(MAX_NUMBER_OF_1):
    (row, column) = seat_position[m]
    arrangement[row, column] = 1

#print("変換後の配置図")    
#print(arrangement)
"""


------20230108以前のメモ------

# coding: utf-8
# Your code here!

import numpy as np

chair = np.zeros((12,18))

for j in range(6):
    for i in range(4):
        chair[1+3*i,1+3*j] = 3
        chair[3*i,3*j] = 2
        chair[3*i,2+3*j] = 2
        chair[2+3*i,2+3*j] = 2
        chair[2+3*i,3*j] = 2

tempList = []
for k in range(12):
    tempList.append(list(map(lambda x:1 if x==0 else x, chair[k])))

chair_converted = np.array(tempList)
print(chair_converted)






print(chair)

chair_converted = np.array(np.array((list(map(lambda x:1 if x==0 else x, chair[0])))))
print(chair_converted)
for k in range(1,12):
    #chair_converted.append(np.array(map(lambda x:1 if x==0 else x, chair[k])))
    chair_converted = np.append(chair_converted,list(map(lambda x:1 if x==0 else x, chair[k])), axis=0)
    #chair_converted = np.append(chair_converted, np.array([0,1,0,1]))

print(chair_converted)





一応どういう処理の流れか簡単に説明すると

①２層のforループで、二次元配列chairの要素にアクセス
②１個目のifにより、0をみつけたらそれを1に変える&カウンターを１個ふやす
③２個目のifがちょっと難しくて、
もしカウンターの数がしきい値を超えたら、breakで内側のforを抜ける。すると、外側のforに用意してあるbreakにつながるので、外側のforも抜ける。それにより、これ以上置き換え処理を行わなくなる
もしカウンターの数がしきい値を超えなければ、else: continueというところにつながる。これは外側のループを1個